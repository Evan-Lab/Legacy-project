from datetime import datetime
import time
from typing import Any, Callable, Self
import pytypes
import templates

from functools import singledispatchmethod, wraps

from djlint import reformat, settings

format_config = settings.Config(
    format_css=True,
    format_js=True,
)


class JinjaGenerator:
    Render = Callable[[Self, Any, bool], str]

    def __init__(self, template: templates.Template):
        self.template = template
        self.result: str | None = None

    def render(self) -> str:
        if self.result is None:
            self.build()
        if self.result is None:
            raise RuntimeError("JinjaGenerator build failed to produce a result")
        return self.result

    @singledispatchmethod
    def _render(self, obj, escape: bool) -> str:
        raise NotImplementedError(f"Rendering not implemented for type: {type(obj)}")

    @staticmethod
    def _escape(fn: Render) -> Render:
        @wraps(fn)
        def wrapper(self, obj, escape: bool) -> str:
            if not escape:
                raise ValueError(f"{fn.__name__} must be called with escape=True")
            return fn(self, obj, escape)

        return wrapper

    @staticmethod
    def _no_escape(fn: Render) -> Render:
        @wraps(fn)
        def wrapper(self, obj, escape: bool) -> str:
            if escape:
                raise ValueError(f"{fn.__name__} must be called with escape=False")
            return fn(self, obj, escape)

        return wrapper

    @_render.register(templates.Template)
    @_escape
    def _render_template(self, template: templates.Template, escape: bool) -> str:
        macros, includes, variables = template.deps()

        macro_list = [
            f"  - {key}({', '.join(macro.args)})"
            for key, macro in macros.items()
        ]

        include_list = [
            f"  - {include.path if include.path else 'raw include'}"
            for _, include in includes.items()
        ]

        variable_list = []
        for _, variable in variables.items():
            for key, var_list in variable.var.items():
                variable_list.append(f"  - {key} (x{len(var_list)})")

        header = f"""
  Generated by JinjaGenerator for template '{template.name}'
    at {datetime.now().isoformat()}

  Used macros:
{(("\n".join(macro_list)) if macros else "  None")}

  Used includes:
{(("\n".join(include_list)) if includes else "  None")}

  Used variables:
{(("\n".join(variable_list)) if variables else "  None")}
"""
        res = r"{# " + header + r"#}" + "\n\n"
        res += self._render(template.tree, True)
        return res

    @_render.register(pytypes.Tree)
    def _render_tree(self, tree: pytypes.Tree, escape: bool, treeOp = "") -> str:
        # rid = f"Tree-{id(tree)}"
        # print(f"Rendering tree {rid} with {len(tree.nodes)} nodes...")
        parts = [self._render(node, escape) for node in tree.nodes]
        res = treeOp.join([p for p in parts if p != ""])
        # print(f"Rendering tree {rid} -> {res[:120]}")
        return res

    @_render.register(pytypes.Node)
    def _render_node(self, node: pytypes.Node, escape: bool) -> str:
        # rid = f"Node-{id(node)}"
        # print(f"Rendering node {rid}: {type(node.value).__name__}...")
        res = self._render(node.value, escape)
        # print(f"Rendering node {rid}: {type(node.value).__name__} -> {res[:120]}")
        return res

    @_render.register(pytypes.AText)
    def _render_value(self, value: pytypes.AText, escape: bool) -> str:
        if value.text == "":
            return ""
        return str(value.text) if escape else '"' + str(value.text) + '"'

    @_render.register(pytypes.AVar)
    def _render_var(self, var: pytypes.AVar, escape: bool) -> str:
        res = r"{{ " if escape else ""
        res += var.path()
        res += r" }}" if escape else ""
        return res

    @_render.register(pytypes.ATransl)
    def _render_transl(self, transl: pytypes.ATransl, escape: bool) -> str:
        res = r"{{ " if escape else ""
        res += "_(\"" + transl.key + "\""
        if transl.variant and transl.variant != "":
            res += f", variant='{transl.variant}'"
        res += r")"
        if transl.capitalize:
            res += r"|capitalize"
        res += r" }}" if escape else ""
        return res

    @_render.register(pytypes.AWidHei)
    def _render_widhei(self, wh: pytypes.AWidHei, escape: bool) -> str:
        return wh.size

    @_render.register(pytypes.AIf)
    # @_escape
    def _render_if(self, if_node: pytypes.AIf, escape: bool) -> str:
        if not escape:
            res = r"(" + self._render(if_node.then_branch, False) + r") if "
            res += r"(" + self._render(if_node.cond, False) + r")"
            if if_node.else_branch.nodes:
                res += r" else (" + self._render(if_node.else_branch, False) + r")"
            return res
        res = r"{% if " + self._render(if_node.cond, False) + r" %}"
        res += self._render(if_node.then_branch, True)
        if if_node.else_branch.nodes:
            res += r"{% else %}"
            res += self._render(if_node.else_branch, True)
        res += r"{% endif %}"
        return res

    @_render.register(pytypes.AForEach)
    @_escape
    def _render_foreach(self, foreach: pytypes.AForEach, escape: bool) -> str:
        return r"{# foreach not implemented yet #}"

    @_render.register(pytypes.AFor)
    @_escape
    def _render_for(self, for_node: pytypes.AFor, escape: bool) -> str:
        res = r"{% for " + for_node.var + r" in "
        res += self._render(for_node.start, False) + r".."
        res += self._render(for_node.end, False) + r" %}"
        res += self._render(for_node.body, True)
        res += r"{% endfor %}"
        return res

    @_render.register(pytypes.ADefine)
    @_escape
    def _render_define(self, define: pytypes.ADefine, escape: bool) -> str:
        res = r"{% macro " + define.name + "("
        res += ", ".join(
            f"{p[0]}={self._render(p[1], False)}" if p[1] else p[0]
            for p in define.params
        )
        res += r") %}"
        res += self._render(define.value, True)
        res += r"{% endmacro %}"
        res += self._render(define.body, True)
        return res

    @_render.register(pytypes.AApply)
    def _render_apply(self, apply: pytypes.AApply, escape: bool) -> str:
        res = r"{{ " if escape else ""
        res += apply.macro + r"("
        res += ", ".join(
            f"{arg[0]}={self._render_tree(arg[1], False, treeOp=' + ')}"
            if arg[0]
            else self._render_tree(arg[1], False, treeOp=' + ')
            for arg in apply.args
        )
        res += r")"
        res += r" }}" if escape else ""
        return res

    @_render.register(pytypes.ALet)
    @_escape
    def _render_let(self, let: pytypes.ALet, escape: bool) -> str:
        res = r"{% with %}"
        res += r"{% set " + let.var + r" = " + self._render(let.value, False) + r" %}"
        res += self._render(let.body, True)
        res += r"{% endwith %}"
        return res

    def _map_op(self, op: str) -> str:
        match op:
            case "=":
                return "=="
            case _:
                return op

    @_render.register(pytypes.AOp1)
    def _render_op1(self, op1: pytypes.AOp1, escape: bool) -> str:
        op = self._map_op(op1.op)
        res = r"{{ " if escape else r""
        res += op + " "
        a = self._render(op1.a, False)
        if a == "":
            a = '""'
        res += a
        res += r" }}" if escape else r""
        return res

    @_render.register(pytypes.AOp2)
    def _render_op2(self, op2: pytypes.AOp2, escape: bool) -> str:
        op = self._map_op(op2.op)
        res = r"{{ " if escape else r""
        a = self._render(op2.a, False)
        if a == "":
            a = '""'
        res += a
        res += " " + op + " "
        b = self._render(op2.b, False)
        if b == "":
            b = '""'
        res += b
        res += r" }}" if escape else r""
        return res

    @_render.register(pytypes.AInt)
    def _render_int(self, aint: pytypes.AInt, escape: bool) -> str:
        return aint.num if not escape else r"{{ " + aint.num + r" }}"

    @_render.register(pytypes.AInclude)
    @_escape
    def _render_include(self, include: pytypes.AInclude, escape: bool) -> str:
        match include.value:
            case pytypes.AInclude.FileInclude():
                return r"{% include '" + include.value.path + ".html.j2" + r"' %}" + "\n"
            case pytypes.AInclude.RawInclude():
                return include.value.raw + "\n"
            case _:
                raise NotImplementedError("AInclude variant not implemented yet")

    @_render.register(pytypes.PUrlFor)
    def _render_url_for(self, url_for: pytypes.PUrlFor, escape: bool) -> str:
        res = r"{{ " if escape else ""
        res += "url_for(\"" + url_for.base + "\""
        res += ", path=\"" + url_for.path + "\""
        res += r")"
        res += r" }}" if escape else ""
        return res

    def build(self):
        result = self._render(self.template, True)
        self.result = reformat.formatter(format_config, result)
        # self.result = result
